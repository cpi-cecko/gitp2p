#!/usr/bin/env perl


use strict;
use warnings;
use v5.20;

use FindBin;
use lib "$FindBin::Bin/lib";

use Getopt::Long;
use Pod::Usage;
use Method::Signatures;
use Path::Tiny;
use IO::Socket::INET;
use Data::Dumper;

use GitP2P::Proto::Relay;
use GitP2P::Proto::Daemon;
use GitP2P::Proto::Packet;
use GitP2P::Core::Finder;
use GitP2P::Core::Common qw/unpack_objects/;


my $cfg = "";
my ($remote, $url) = @ARGV;

sub echo($) {
    my $str = shift;
    system "echo", $str;
}

sub echo_empty {
    system "echo", "";
}

func get_repo_info(Str $url) {
    # gitp2p://<user_name>/<repo_name>
    if ($url !~ /^gitp2p:\/\/([a-z0-9@.-]*)\/(.*)$/) {
        die "Invalid url: $url";
    }
    return ($1, $2);
}


func do_capabilities() {
    echo "fetch";
    echo "list";
    echo_empty;
}

func do_list() {
    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    my ($owner, $repo) = get_repo_info($url);

    my $msg = GitP2P::Proto::Relay::build("get-peers", [$repo, $owner]);

    $s->send($msg);

    my $resp = <$s>;
    chomp $resp;

    close $s;

    die "Bad resp: '$resp'"
        if ($resp =~ /^NACK/);

    my @peers = split /,/, $resp;

    my $list_msg = GitP2P::Proto::Daemon::build_comm("list", [$repo]);
    my $pS = GitP2P::Core::Finder::establish_connection($peers[0], $cfg);

    $pS->send($list_msg);
    
    $resp = <$pS>;
    chomp $resp;

    close $pS;

    my $refs = GitP2P::Proto::Daemon->new;
    $refs->parse($resp);

    my $cnts = $refs->op_data;

    for my $ref (split /\n/, $cnts) {
        $ref =~ s/\t+/ /g;
        echo "$ref";
    }
    echo_empty;
}

func do_fetch(ArrayRef[Str] $refs) {
    my ($owner, $repo) = get_repo_info($url);
    my $relay_msg = GitP2P::Proto::Relay::build("get-peers", [$repo, $owner]);

    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    $s->send($relay_msg);

    my $resp = <$s>;
    chomp $resp;

    close $s;

    die "Bad resp: '$resp'"
        if ($resp =~ /^NACK/);

    my @want;
    my $out = `git show-ref 2>gitp2p.stderr`; # TODO: Check for error
    my @my_refs = split /\n/, $out;
    for (@$refs) {
        warn "Getting wants";
        $_ =~ /^([a-f0-9]{40}).*$/;
        push @want, $1
            if not grep { $_ } @my_refs;
    }

    my @have;
    # Runs git-unpack-objects because we currently don't know how to do unpack
    # by hand
    # TODO: Finding the .git repo is not so simple
    my $repo_root = path("./.git");
    if ($repo_root->exists) {
        warn "Getting haves";
        my $obj_dir = $repo_root->child("objects/pack");
        $obj_dir->child("pack")->exists
            and $repo_root->child("pack")->children
                and unpack_packs($repo_root->child("pack"), $obj_dir);

        my @obj_parents = $obj_dir->children(qr/^\d\d/);
        my @objects = map {
                        my $dir = $_;
                        map {
                            $dir->absolute . "/" . $_->basename;
                        } $dir->children;
                      } @obj_parents;

        @have = @objects;
    }

    warn "Wants: " . scalar @want;
    my $packet = GitP2P::Proto::Packet->new;
    for (@want) {
        $packet->write("want $_");
    }

    warn "Haves: " . scalar @have;
    for (@have) {
        $packet->write("have $_");
    }

    # TODO: Handle dead peers
    # Send desires
    my @peers = split /,/, $resp;
    my %peer_info;
    my $id = 0; # Used to determine what each pear will send
    for my $peer (@peers) {
        my $peer_packet = GitP2P::Proto::Packet->new;

        # pkt_line format ABNF
        # message = repo NL id NL *wants *haves
        #
        # repo = "repo" SP user_id SP repo_name
        # id = "id" SP 1*DIGIT SP 1*DIGIT
        # wants = "want" SP obj-id NL
        # haves = "have" SP obj-id NL
        #
        # user_id = *ALNUM
        # repo_name = *ALNUM
        $peer_packet->write("repo $repo $owner");
        $peer_packet->write("id $id " . scalar @peers);
        $peer_packet->append(\$packet);

        #my $hexed = join "", map { sprintf "%02x", ord $_ } split //, $peer_packet->to_send;
        warn $peer_packet->to_send;
        my $pS = GitP2P::Core::Finder::establish_connection($peer, $cfg);
        my $pack = GitP2P::Proto::Daemon::build_data(
              "fetch", { 'user_id' => "dummy", 
                         'type' => "pkt_line",
                         'hash' => "dummy",
                         'cnts' => $peer_packet->to_send});
        warn $pack;
        $pS->send($pack); 

        $peer_info{$peer} = { id => $id
                            , sock => $pS
                            };

        $id++;
    }

    # Receives objects
    for my $peer (@peers) {
        # TODO: Fork
        my $pS = $peer_info{$peer}->{sock};
        my $obj = <$pS>;
        chomp $obj;
        while ($obj !~ /^end$/) {
            warn "receives $obj";
            my $parsed_obj = GitP2P::Proto::Daemon->new;
            $parsed_obj->parse($obj);
            my (undef, undef, $hash) = split /:/, $parsed_obj->op_info;
            my $cnts = $parsed_obj->op_data;
            my ($dir, $file) = (substr($hash, 0, 2), substr($hash, 2));
            my $obj_path = path("$repo/.git/objects/$dir/$file")->touchpath;
            $obj_path->spew({binmode => ":raw"}, ($cnts));
            # Debug
            # path("temp/$dir/$file")->touchpath->spew({binmode => ":raw"}, ($cnts));

            $obj = <$pS>;
        }
        close $pS;
    }
}


while (<STDIN>) {
    chomp;
    next if $_ =~ /^\s*$/;
    warn $_;

    $_ =~ /^(\w+)\s?/;
    my ($cmd) = $1;
    if ($cmd =~ /capabilities/) {
        do_capabilities();
    }
    elsif ($cmd =~ /list/) {
        do_list();
    }
    elsif ($cmd =~ /fetch/) {
        $_ =~ /^\w+\s(.*)$/;
        my @refs = ($1);

        while (<STDIN>) {
            last if $_ =~ /^\s*$/;

            $_ =~ /^\w+\s(.*)$/;
            push @refs, $1;
        }

        do_fetch(\@refs);

        echo_empty;
    } 
    else {
        die "Invalid capability '$cmd'";
    }
}




=begin comment
my $man = 0;
my $help = 0;
my $cfg = ""; # Currently, the config only contains the port number

GetOptions('help|?'  => \$help, 
           man       => \$man,
           'cfg=s'   => \$cfg,
           'init=s'  => \&repo_init,
           upload    => \&repo_upload,
           push      => \&repo_push,
           # TODO: Remote branches. Don't add them to repo. FETCH_HEAD.
           fetch     => \&repo_fetch,
           'clone=s' => \&repo_clone,
           list      => \&repo_list,
       ) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;


# Accepts a repo_dir and user_id
# TODO: Try to deduce repo_dir and user_id if not present
# TODO: The user.email is not a user id!!!
# TODO: Make HEAD point to master after creation
func repo_init(Object $opt_name, Str $init_params) {
    # TODO: Check if there's a valid repo at $repo_dir
    my ($repo_dir, $owner_id) = split /:/, $init_params;
    # TODO: Use pod2usage
    die ("gitp2p --init <repo_dir>:<owner_id>")
        if not $owner_id;

    my $working_dir = path($repo_dir)->absolute;
    if (length($working_dir) == 0) {
        $working_dir = Path::Tiny->cwd;
    }

    say "[INFO] Working in $working_dir";

    my $repo_name = path($working_dir)->basename;
    my $bare_repo_path = "$working_dir/../$repo_name.git";
    say "[INFO] Bare repo path $bare_repo_path";
    
    system("cp", "-rf", "$working_dir/.git", $bare_repo_path);
    die ("couldn't copy repo")
        if $? == -1;

    system("git", "config", "--file", "$bare_repo_path/config", "--bool", "core.bare", "true");
    system("rm", "-rf", $bare_repo_path)
        if $? == -1;
    system("git", "config", "--file", "$bare_repo_path/config", "user.email", "$owner_id");
}

# Fetches the list of available relays and uploads the repo's address there
func repo_upload(Object $opt_name, Str $dummy) {
    my $repo_name = path(path("./")->absolute)->basename;
    # TODO: Don't try to guess the repo path
    # TODO: The command can simply be invoked at the root of a dir containing
    #       the working dir and the bare repo. Therefore, the path to the
    #       config can either be ../$repo_name.git/config or $repo_name.git/config
    die ("No bare repo config at " . path("../$repo_name.git/config")->absolute)
        if not path("../$repo_name.git/config")->exists;
    my $owner_id = `git config --file ../$repo_name.git/config --get user.email`;
    chomp $owner_id;

    # TODO: git gc after upload

    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    my $msg = GitP2P::Proto::Relay::build("upload", [$repo_name, $owner_id]);

    say "[INFO] Message '$msg'";
    $s->send($msg);

    my $resp = <$s>;
    chomp $resp;

    say "[INFO] Response: $resp";
    close $s;
}

# Pushes the repo across the swarm of subscribers
func repo_push(Object $opt_name, Str $dummy) {
    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    # TODO: Read the local or the global git config?
    my $user_id = `git config --local --get user.email`;
    chomp $user_id;
    my $repo_name = path(path("./")->absolute)->basename;

    my $msg = GitP2P::Proto::Relay::build("push", [$repo_name, $user_id]);

    say "[INFO] Message '$msg'";
    $s->send($msg);

    # expected: comma-sepd ip:port of peers
    my $resp = <$s>;
    chomp $resp;
    if (grep { /NACK:/ } $resp) {
        say "[INFO] No peers";
        return;
    }

    my @peers_addr = split /,/, $resp;

    # system ("git", "gc");
    for my $peer (@peers_addr) {
        # my $pS = GitP2P::Core::Finder::establish_connection($peer, 47778);
        my $packDir = path(".git/objects/pack");
        for my $packFile ($packDir->children) {
            if ($packFile =~ /\.idx$/) {
                my $contents = path($packFile)->slurp_raw;
                my $msg = GitP2P::Proto::Daemon::build_data("recv",
                    {'user_id' => $user_id, 
                     'type' => "idx",
                     'cnts' => $contents});
                say "Sending index of " . (length $msg) . " bytes to $peer";
                # $pS->send($msg);
            }
            elsif ($packFile =~ /\.pack$/) {
                my $contents = path($packFile)->slurp_raw;
                my $msg = GitP2P::Proto::Daemon::build_data("recv", 
                    {'user_id' => $user_id, 
                     'type' => "pack",
                     'cnts' => $contents});
                say "Sending pack of " . (length $msg) . " bytes to $peer";
                # $pS->send($msg);
            }
        }
        # close $pS;
    }

    close $s;
}

# Clones a repo by a given name and user id
func repo_clone(Object $opt_name, Str $opt_params) {
    # $my_user_id is just an optional param for testing.
    my ($repo_name, $owner_id, $my_user_id) = split ':', $opt_params;

    # TODO: Check if user has specified .git at the end of $repo_name
    # TODO: Escape $repo_name
    system("git", "init", "--bare", "../$repo_name.git");
    die "Couldn't init bare repo"
        if $? == -1;
    system("git", "config", "--file", "../$repo_name.git/config", "user.email", "$my_user_id")
        if $my_user_id;
    die "Couldn't set user.email"
        if $? == -1;

    system("git", "init");
    die "Couldn't init repo"
        if $? == -1;

    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    my $msg = GitP2P::Proto::Relay::build("clone", [$repo_name, $owner_id]);

    say "[INFO] Message '$msg'";
    $s->send($msg);
     
    my $resp = <$s>;
    chomp $resp;

    say "[INFO] Response '$resp'";
    close $s;

    # Gets first peer, asks for objects count, divides the count on the number
    # of peers.
    # Sends each pear, count + offset in the objects. They give them sorted by
    # SHA1.
    my @peers = split ',', $resp;
    my $info_msg = GitP2P::Proto::Daemon::build_comm("obj_count", [$repo_name]);

    my $pS = GitP2P::Core::Finder::establish_connection($peers[0], $cfg);
    $pS->send($info_msg);

    my $count = <$pS>;
    chomp $count;

    close $pS;

    say "Count: $count";
    say "Peers: @peers";

    # TODO: Check count
    my $divide = $count / scalar @peers;
    my $offset = 0;
    for my $peer (@peers) {
        $pS = GitP2P::Core::Finder::establish_connection($peer, $cfg);
        my $objs_req = GitP2P::Proto::Daemon::build_comm("give", [$repo_name, $divide, $offset]);
        $offset += $divide;
        $pS->send($objs_req);
        my $msg = <$pS>;
        chomp $msg;
        while ($msg !~ /^end$/) {
            my $parsed_msg = GitP2P::Proto::Daemon->new;
            $parsed_msg->parse($msg);
            # TODO: BEWARE! Proto::Daemon has been changed!
            my (undef, undef, $hash, $cnts) = split /:/, $parsed_msg->op_data;
            my ($dir, $file) = (substr($hash, 0, 2), substr($hash, 2));
            my $obj_path = path("../$repo_name/.git/objects/$dir/$file")->touchpath;
            $obj_path->spew(($cnts));
            $msg = <$pS>;
        }

        close $pS;
    }
}

# Lists available repos
func repo_list(Object $opt_name, Str $dummy) {
    my $relay = GitP2P::Core::Finder::get_relay("gitp2p-config");
    my $s = GitP2P::Core::Finder::establish_connection($relay, $cfg);

    my $msg = GitP2P::Proto::Relay::build("list", [""]);

    say "[INFO] Message '$msg'";
    $s->send($msg);

    my $resp = <$s>;
    chomp $resp;

    say "Available repos: \n  " . join "\n  ", split /, /, $resp;
    close $s;
}
=end comment
=cut


__END__

=head1 NAME

gitp2p - A peer-to-peer git hosting service.

=head1 SYNOPSIS

gitp2p [--help, --man, --cfg config-file, --init [repo-dir], --upload, --push,
        --fetch, --clone user_id:repo_name, --list]

 Options:
   -help        brief help message
   -man         full documentation

   -cfg         specify config file for overriding default options

   -init        init a bare git repo from the repo at [repo-dir]
   -upload      upload an initted bare repo to the p2p swarm
   -push        push changes to the swarm
   -fetch       fetch changes from the swarm
   -clone       clone repo from the swarm
   -list        lists available gitp2p repos

=head1 OPTIONS

=over 8

=item B<-help>

Prints a brief help message and exits.

=item B<-man>

Prints the manual page and exits.

=item B<-cfg>

Override defaults from a config file.

=item B<-init>

Init a bare git repository on your machine from the repo at [repo-dir].
If no such directory is specified, gitp2p uses the directory you're currently
in.

=item B<-upload>

Upload the initialized bare repository to the gitp2p swarm. This basically
shares the repository and adds it to the global broadcast board where it
could be pulled and shared by other peers.

=item B<-push>

Pushes your changes to the gitp2p swarm.

=item B<-fetch>

Fetches the latest repo changes from the gitp2p swarm.

=item B<-clone>

Clones a given repo.

=item B<-list>

Lists available gitp2p repositories.

=back

=head1 DESCRIPTION

B<gitp2p> is designed to provide peer-to-peer git hosting capabilities.
This way, the open-source community could establish free and stable 
repositories for sharing and working on great projects.

=cut
