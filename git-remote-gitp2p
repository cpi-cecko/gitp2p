#!/usr/bin/env perl


use strict;
use warnings;
use v5.020;

use FindBin;
use lib "$FindBin::Bin/lib";

use Getopt::Long;
use Pod::Usage;
use Method::Signatures;
use Path::Tiny;
use IO::Socket::INET;
use IO::Select;
use Data::Dumper;
use IPC::Open2;
use File::pushd;
use JSON::XS;

use GitP2P::Proto::Relay;
use GitP2P::Proto::Daemon;
use GitP2P::Proto::Packet;
use GitP2P::Core::Finder;
use GitP2P::Core::Common;


my $cfg_file = "./gitp2p-config" if path("./gitp2p-config")->exists;
# TODO: Check for undef $cfg_file
my $cfg = JSON::XS->new->ascii->decode(path($cfg_file)->slurp) 
    if $cfg_file ne "";

my ($remote, $url) = @ARGV;

sub echo($) {
    my $str = shift;
    system "echo", $str;
}

sub echo_empty {
    system "echo", "";
}

func get_repo_info(Str $url) {
    # gitp2p://<user_name>/<repo_name>
    if ($url !~ /^gitp2p:\/\/([a-z0-9@.-]*)\/(.*)$/) {
        die "Invalid url: $url";
    }
    return ($1, $2);
}


func do_capabilities() {
    echo "fetch";
    echo "list";
    echo_empty;
}

func do_list() {
    my ($owner, $repo) = get_repo_info($url);
    my $msg = GitP2P::Proto::Relay::build("get-peers", [$repo, $owner]);

    my $s = GitP2P::Core::Finder::connect_to_relay(\$cfg);
    $s->send($msg);

    my $resp = <$s>;
    chomp $resp;

    close $s;

    die "Bad resp: '$resp'"
        if ($resp =~ /^NACK/);

    my @peers = split /,/, $resp;

    my $pS = GitP2P::Core::Finder::establish_connection($peers[0], \$cfg);
    while (!$pS && shift @peers) {
        $pS = GitP2P::Core::Finder::establish_connection($peers[0], \$cfg);
    }
    die "Can't connect with peers for repo"
        if !$pS && $#peers == -1;

    my $list_msg = GitP2P::Proto::Daemon::build_comm("list", [$repo]);
    $pS->send($list_msg);
    
    $resp = <$pS>;
    chomp $resp;

    close $pS;

    my $refs = GitP2P::Proto::Daemon->new;
    $refs->parse(\$resp);

    my $cnts = $refs->op_data;

    for my $ref (split /\n/, $cnts) {
        $ref =~ s/\t+/ /g;
        echo "$ref";
    }
    echo_empty;
}

# TODO: Use GitP2P::Core::Common::show_refs
func get_wants(ArrayRef[Str] $refs, Str $repo_dir) {
    my @want;
    my $out;
    {
        my $dir = pushd "./$repo_dir";
        $out = `git show-ref`;
    }
    my @my_refs = split /\n/, $out;
    for (@$refs) {
        warn $_;
        $_ =~ /^([a-f0-9]{40}).*$/;
        push @want, $1
            if not grep { $_ } @my_refs;
    }

    return @want;
}

func get_haves(Str $repo_dir) {
    GitP2P::Core::Common::list_objects("./$repo_dir");
}

func create_objects_packet(ArrayRef[Str] $refs) {
    my $repo_dir;
    if (path(".git")->exists) {
        $repo_dir = "/";
    } else {
        (undef, $repo_dir) = get_repo_info($url);
    }

    my @want = get_wants($refs, $repo_dir);
    warn "Wants: " . scalar @want;
    my $packet = GitP2P::Proto::Packet->new;
    for (@want) {
        $packet->write("want $_");
    }

    my @have = get_haves($repo_dir);
    warn "Haves: " . scalar @have;
    for (@have) {
        $packet->write("have $_");
    }

    return $packet;
}

func do_fetch(ArrayRef[Str] $refs) {
    my ($owner, $repo) = get_repo_info($url);
    my $relay_msg = GitP2P::Proto::Relay::build("get-peers", [$repo, $owner]);

    my $s = GitP2P::Core::Finder::connect_to_relay(\$cfg);
    $s->send($relay_msg);

    my $resp = <$s>;
    chomp $resp;

    close $s;

    die "Bad resp: '$resp'"
        if ($resp =~ /^NACK/);

    my $packet = create_objects_packet($refs);

    my @peers = split /,/, $resp;
    receive_objects(\@peers, $repo, $owner, $packet, $refs);

    # Ugly hack which adds by hand the HEAD reference to .git/packed-refs
    my $master_ref = (grep { $_ =~ qr(refs/heads/master$) } @$refs)[0];
    system "echo $master_ref >> $repo/.git/packed-refs";
}

func receive_objects(ArrayRef[Str] $peers, Str $repo, Str $owner, 
                     GitP2P::Proto::Packet $packet, ArrayRef[Str] $refs) {
    my $pSelect = IO::Select->new;

    # Send desires
    my $id = 0; # Used to determine what each peer will send
    for my $peer (@$peers) {
        my $peer_packet = GitP2P::Proto::Packet->new;

        $peer_packet->write("repo $repo $owner");
        $peer_packet->write("id $id " . scalar @$peers);
        $peer_packet->append(\$packet);

        # TODO: If can't connect, remove peer.
        # TODO: How shall we reasign the ids?
        my $pS = GitP2P::Core::Finder::establish_connection($peer, \$cfg);
        $pSelect->add($pS);
        my $pack = GitP2P::Proto::Daemon::build_data(
              "fetch_pkt_line", \$peer_packet->to_send);
        warn $pack;
        $pS->send($pack); 

        $id++;
    }

    my $TIMEOUT_SECS = 3;
    my @available_peers;
    while (my @ready = $pSelect->can_read($TIMEOUT_SECS)) {
        for my $peer (@ready) {
            my $obj = <$peer>;
            chomp $obj;
            while ($obj !~ /^end$/) {
                my $parsed_obj = GitP2P::Proto::Daemon->new;
                $parsed_obj->parse(\$obj);
                my $cnts = $parsed_obj->op_data;
                
                my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 
                    "git", "index-pack", "-v", "--stdin", "--fix-thin", "--keep");
                print CHLD_IN $cnts;
                while (<CHLD_OUT>) {
                    warn "git-index-pack: $_";
                }

                $obj = <$peer>;
            }
            push @available_peers, $peer->peerhost . ":" . $peer->peerport;
            $pSelect->remove($peer);
            $peer->close;
        }
    }

    # TODO: Should we also check whether we have all objects?
    return unless $pSelect->count;

    # Retry in order to get the rest of the objects
    my $remaining_packet = create_objects_packet($refs);
    receive_objects(\@available_peers, $repo, $owner, $remaining_packet, $refs);
}


while (<STDIN>) {
    chomp;
    next if $_ =~ /^\s*$/;
    warn $_;

    $_ =~ /^(\w+)\s?/;
    my ($cmd) = $1;
    if ($cmd =~ /capabilities/) {
        do_capabilities();
    }
    elsif ($cmd =~ /list/) {
        do_list();
    }
    elsif ($cmd =~ /fetch/) {
        $_ =~ /^\w+\s(.*)$/;
        my @refs = ($1);

        while (<STDIN>) {
            last if $_ =~ /^\s*$/;

            $_ =~ /^\w+\s(.*)$/;
            push @refs, $1;
        }

        do_fetch(\@refs);

        echo_empty;
    } 
    else {
        die "Invalid capability '$cmd'";
    }
}
