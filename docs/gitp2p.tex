\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\inputencoding{utf8}
\usepackage[bulgarian]{babel}
\usepackage{graphicx}
\selectlanguage{bulgarian}

\title{Peer-to-Peer Хостинг на git Хранилища}
\date{13 Юни, 2015}
\author{Цветан Цветанов, студент 2 курс, ИС, ФМИ}

\begin{document}

\maketitle

\section{Въведение}

Този проект представя имплементация на система за peer-to-peer хостинг на git
хранилища. Системата е вдъхновена от 
BitTorrent\footnote{https://en.wikipedia.org/wiki/BitTorrent}, 
GitTorrent протокола\footnote{https://code.google.com/p/gittorrent/} и 
излязлата в края на май месец, тази година, 
GitTorrent имплементация\footnote{https://github.com/cjb/GitTorrent} на базата
на BitTorrent. Всички те целят децентрализация и свобода на интернет ресурсите.

\section{Мотивация}

Свободният софтуер има нужда от свободни инструменти за разработката му. \textbf{git} е
система за контрол на версиите, която доби изключителна популярност поради
децентрализирания си характер. Проблемът е, че независимо колко децентрализирана
е тази система, почти винаги излиза нужда от централен сървър, на който да се 
държи хранилище, от което всички да се сдобиват с последните версии на кода,
който бива разработван за да могат да надграждат над него. Това е сериозна точка
на уязвимост, както беше показано със скорошната DDoS атака
върху github.com\footnote{https://github.com/blog/1981-large-scale-ddos-attack-on-github-com}.

При положение, че git доста лесно може да се възползва от различен набор централни
хранилища, защо да не имплементираме такава система? Ще спечели независимост,
неуязвимост и автоматизация. Базовата имплементация на gitp2p е първата стъпка
към това.

\section{Архитектура}

\subsection{}

git е имплементиран, така че много лесно да се надгражда с протоколи за 
комуникация. Нещото, което върши тази работа се нарича git-remote-helper. Общо
взето, когато напишем команда от рода на git clone <protocol>://<repo>, ако
git не разбира протокола ни, ще направи опит да намери remote-helper, който да
му покаже как да извърши дадената операция. В нашия случай, remote-helper е
git-remote-gitp2p.

Намирайки този remote-helper, git го стартира като подпроцес и на стандартния
му вход почва да праща команди. Първата команда, на която даден remote-helper
трябва да отговори е capabilities. Тази команда се използва за да се разбере
какво може да прави нашият протокол. Отоговорът е списък с избрани възможности
от следните: connect, push, fetch, import, export. След като сме пратили
възможностите си на git, той праща команда list, с която споделяме всички ref 
обекти, които има в дадено хранилище. На базата на тях, ще определим кои обекти
на дадем чрез fetch. За push, има съответно list for-push. Повече за системата
може да се прочете в man страницата за git-remote-helpers\footnote{https://www.kernel.org/pub/software/scm/git/docs/gitremote-helpers.html}.

\subsection{}

За достъп до информация за своите пиъри, gitp2p използва така нареченото relay,
което е единствената централна точка в системата. В бъдеще, този проблем може 
да се реши посредством имплементация на DHT или подобен метод за индексация на
ресурси в peer-to-peer мрежа.

Понеже за сега е имплементирана само git clone командата, ще разкажа как работи
тя.

След като изпълним git clone gitp2p://<repo-owner>/<repo-name>, git се свързва
с git-remote-gitp2p, и праща команда list. Когато получи команда list, gitp2p 
протокола се свързва с relay, за да се сдобие със списък с пиърите за дадено
хранилище. Вариантите са два - или да получи въпросния списък, или да получи
NACK. При NACK няма какво да правим - не можем да се сдобием с хранилището. При
получаване на въпросния списък, взимаме първия пиър, свързваме се с него и го
питаме за това какви ref обекти може да ни предложи. Той праща тази информация,
а ние я препращаме към git.

\begin{verbatim}
 

git-remote-list
===============

+---+                       +-----+
|git|                +----->|relay|
+---+               /       +-----+
  |           _____/          3|
1 | list     /get-peers   /----+  
  v    _____/       _____/            +-----+
+--+  /            /        +-----+   |peer2|
|me|-/2     peers /         |peer1|   +-----+
+--+<------------/          +-----+
^ 4|     list                  ^ |5
|  \---------------------------+ |
---------------------------------+
    repo_refs
\end{verbatim}

Следващата команда, която предстои е fetch. При нея, git ни праща, на отделен ред
всеки обект, който можем да получим, на базата на ref обектите, които сме пратили
при list. На базата на тези получени обекти, ние създаваме два списъка. Единият
е wants, другият е haves. В първия държим sha1 id-тата на ref обектите, от които
имаме нужда. В другия споделяме всички обекти, които имаме в наличност. При
случая с git clone, втория списък ще е празен - ние нямаме никаква част от 
хранилището при нас.

След като създадем тези списъци, ние се свързваме с relay за да го попитаме
какви пиъри са налични. То ни праща отговор с адреси на налични пиъри, разделени
със запетайки.

Имайки броя и наличните пиъри, ние изчисляваме кой пиър с каква част от
хранилището трябва да ни сдобие. Алгоритъмът е прост и ненадежден, но като за 
прототипна имплементация върши работа. Той е следния - всеки пиър праща всеки
k-ти обект от някакво начало. Например, ако имаме три пиъра и 10 обекта, първият
пиър ще прати 0,3,6,9 обект, вторият пиър ще прати 1,4,7,10 обект, а третия пиър
ще прати 2,5,8 обект. Естествено, тази схема не взима предвид ситуацията, при
която загубваме връзка с някой от пиърите или пък не разпределяме равномерно
натоварването.

Сдобили се с всички обекти, ние ги записваме в локалното хранилище. След това,
пращаме заявка към relay за да ни добави към списъка с пиърите. Тук операцията
приключва.

\begin{verbatim}


git-remote-fetch
================

                      +---+             
                      |git|             
                      +---+             
                        | (1) fetch
         (2) get peers  V    (4) want_packet     +-----+
+-----+<---------------+--+--------------------->|peer2|
|relay|--------------->|  |<---------------------+-----+
+-----+  (3) peers     |  |     recv_want        
                       |me|      want_packet
                       |  |--------------------->+-----+
                       +--+<---------------------|peer1|
                                recv_want        +-----+

\end{verbatim}

\section{Протоколи}

Системата работи с три протокола. Един за комуникация с relay, един за комуникация
с другите пиъри и един за пращане на данни между пиърите. Освен това, се използва
специална структура pkt\_line, която служи за предаването на wants и haves данните.

\subsection{}

Протоколът за комуникация с relay е сравнително прост. Той е съставен от име на
дадената операция, последвано от празно място, последвано от разделени с двуеточие
данни.

\begin{verbatim}
relay protocol format ABNF
==========================

message = op-name SP op-data

op-name = *("_" "a"."z" "A"."Z")
op-data = *(ALNUM ":")
\end{verbatim}

\subsection{}

Протоколът за комуникация с другите пиъри е малко по-сложен. Първо, той се
разделя на два типа - такъв за данни и такъв за команди. Нуждата от разделянето
е поради простата причина, че когато обменяме данни може да ни се наложи да
вкараме сериозни оптимизации с цел намаляване на обема на пакетите.

Когато обменяме команди, първият байт в съобщението е "c". След това следва името
на командата, а след това, нейните параметри. При обмяната на данни съобщението
започва с байт "d", командата, четири задължителни информационни параметъра
и base64 енкоднати данни.

\begin{verbatim}
Daemon protocol format ABNF
===========================

message   = type op_name SP data

type      = d / c
op_name   = Str
data      = (1*(ops ":"))                          ; type == c
          / (user_id SP data_type SP hash SP cnts) ; type == d

user_id   = Str
data_type = Str
hash      = obj-id
cnts      = *base64_Chr
\end{verbatim}

\subsection{}

Накрая идва и pkt\_line протокола, който се обгръща от Daemon протокол за данни.
Неговият пръв ред дава информация за хранилището и потребителя, който го ползва.
Втория ред дава информация за алгоритъма на взимане на обекти. Накрая имаме
редове, всеки от който започва с "want" или "have" и sha1 на обекта, който 
искаме или имаме.

\begin{verbatim}
pkt\_line format ABNF
====================

message = repo NL id NL *wants *haves

repo = "repo" SP user_id SP repo_name
id = "id" SP 1*DIGIT SP 1*DIGIT
wants = "want" SP obj-id NL
haves = "have" SP obj-id NL

user_id = *ALNUM
repo_name = *ALNUM
\end{verbatim}

\section{Какво още е нужно?}

Този прототип на първо място е много несигурен. Никой не дава гаранция, че 
хранилището, което се опитвам да достигна е правилното. Тоест, аз бих могъл
лесно да се сдобия с данни, които да ми навредят.

Другият проблем, който има е, че няма начин, веднъж като съм подал информация
на пиърите какви обекти искам, да засеча ако някой от тях е умрял в процеса.
Тоест, има голяма вероятност да не мога да се сдобия с цялото хранилище.

В момента relay не следи за здравето на пиърите и не обновява списъка с адресите
както е нужно.

Протоколите нямат версии и сигнатури. Също така, не се остановява никакъв процес
на handshake.

Daemon протокола има нужда от рефакториране и евентуално разделяне на два отделни
протокола.

Има сериозни, но пропуснати възможности за паралелизация на някои части от кода.

За да се сдобием с обектите на пиърите, първо разпакетираме pack файловете в
съответното git хранилище. Това е бавен процес и има възможности за подобрение.

Трябва да се имплементира git push.

Доста от особеностите на споделяне на нужни обекти не са взети предвид.

Въпреки всички забележки, това е един интересен прототип, върху който ще бъде
надграждано и евентуално ще основоположи peer-to-peer независимото споделяне
на git хранилища.

\end{document}
